<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Study Words - Tr·∫Øc nghi·ªám</title>
  <style>
    /* CSS gi·ªØ nguy√™n */
    * {
      box-sizing: border-box;
    }
    
    body { 
      font-family: Arial, sans-serif; 
      margin: 0;
      padding: 15px;
      font-size: 16px;
      line-height: 1.5;
      background-color: #121212;
      color: white;
    }
    
    button { 
      margin: 8px 0;
      padding: 12px 16px;
      font-size: 16px;
      border: 1px solid #444;
      border-radius: 8px;
      background-color: #333;
      color: white;
      width: 100%;
      cursor: pointer;
      display: block;
    }
    
    .word-card { 
      border: 1px solid #444; 
      padding: 15px; 
      margin-top: 15px; 
      border-radius: 8px;
      background-color: #1e1e1e;
    }
    
    #feedback { 
      font-weight: bold; 
      margin-top: 15px;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
    }
    
    .result-item { 
      margin: 10px 0; 
      padding: 10px;
      border-bottom: 1px solid #333;
    }
    
    .action-buttons { 
      margin-top: 20px; 
    }
    
    .hidden-text { 
      color: transparent; 
    }
    
    .show-text-btn { 
      background: #333; 
      border: 1px dashed #666; 
      margin-right: 10px;
    }
    
    .next-btn {
      background: #1976d2;
      margin-top: 15px;
    }
    
    .correct-answer {
      background: green !important;
    }
    
    .incorrect-answer {
      background: darkred !important;
    }
    
    .action-container {
      display: flex;
      gap: 10px;
      margin: 15px 0;
    }
    
    .action-container button {
      width: auto;
      flex: 1;
    }

    .progress-counter {
      position: fixed;
      top: 15px;
      right: 15px;
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 14px;
      font-weight: bold;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    
    @media (min-width: 768px) {
      body {
        max-width: 600px;
        margin: 0 auto;
      }
      
      .word-card button {
        width: 100%;
        margin: 5px 0;
      }
      
      .action-container button {
        width: auto;
        margin: 0;
      }
    }
  </style>
</head>
<body>
  <div id="progressCounter" class="progress-counter">0/0/0r/0w</div>
  <div id="output"></div>
  <div id="feedback"></div>

  <script>
    // L·∫•y t·ª´ v·ª±ng t·ª´ choose.html - ch·ªâ l·∫•y t·ª´ level 0
    let allVocabularies = JSON.parse(localStorage.getItem("vocabularies") || "[]");
    let words = JSON.parse(localStorage.getItem("selectedStudyWords") || "[]");

    if (words.length === 0) {
      document.getElementById("output").innerHTML = "<p>‚ùå Kh√¥ng c√≥ t·ª´ n√†o ƒë·ªÉ h·ªçc! Vui l√≤ng quay l·∫°i ch·ªçn t·ª´.</p>";
      document.getElementById("output").innerHTML += `<br><button onclick="goBack()">‚Ü©Ô∏è Quay l·∫°i trang ch·ªçn t·ª´</button>`;
    }

    const MODES = ["en_vi", "vi_en"];
    let currentModeIndex = 0;
    let wordQueue = [...words];
    let currentWord = null;
    let firstAttempt = true;
    let hasShownText = false;
    
    let wordResults = {};
    let results = [];
    let wrongQuestions = [];

    // Bi·∫øn ƒë·∫øm ti·∫øn tr√¨nh
    let totalWords = words.length;
    let currentQuestion = 0;
    let correctAnswers = 0;
    let wrongAnswers = 0;

    function goBack() {
      window.location.href = "choose.html";
    }

    function updateProgressCounter() {
      const counter = document.getElementById('progressCounter');
      counter.innerHTML = `${totalWords}/${currentQuestion}/${correctAnswers}r/${wrongAnswers}w`;
    }

    // Ph√°t √¢m t·ª´ - D√ôNG WEB SPEECH API (ƒê√É S·ª¨A)
    function playAudio(w) {
      if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(w);
        utterance.lang = 'en-US';
        utterance.rate = 0.8;
        speechSynthesis.speak(utterance);
      }
    }

    function nextQuestion() {
      document.getElementById("feedback").innerHTML = "";
      hasShownText = false;
      firstAttempt = true;
      
      if (wordQueue.length === 0) {
        if (currentModeIndex < MODES.length - 1) {
          currentModeIndex++;
          wordQueue = [...words];
          nextQuestion();
          return;
        }
        showResults();
        return;
      }

      currentWord = wordQueue.shift();
      firstAttempt = true;

      let question, correctAnswer;
      if (MODES[currentModeIndex] === "en_vi") {
        question = `<span class="hidden-text">${currentWord.w} [${currentWord.p}]</span>`;
        correctAnswer = currentWord.m;
      } else {
        question = currentWord.m;
        correctAnswer = currentWord.w;
      }

      currentQuestion++;
      updateProgressCounter();
      
      renderQuiz(question, correctAnswer, currentWord.w);
      
      // T·ª∞ ƒê·ªòNG PH√ÅT √ÇM THANH KHI B·∫ÆT ƒê·∫¶U C√ÇU H·ªéI en-vi
      if (MODES[currentModeIndex] === "en_vi") {
        setTimeout(() => {
          playAudio(currentWord.w);
        }, 300);
      }
    }

    function renderQuiz(question, correctAnswer, audioWord) {
      const container = document.getElementById("output");

      let otherOptions = words
        .filter(w => (MODES[currentModeIndex]==="en_vi"? w.m !== correctAnswer : w.w !== correctAnswer))
        .map(w => MODES[currentModeIndex]==="en_vi"? w.m : w.w)
        .slice(0,3);

      let options = [correctAnswer, ...otherOptions].sort(() => Math.random()-0.5);
      
      const displayQuestion = MODES[currentModeIndex] === "en_vi" 
        ? question 
        : question;
      
      const actionButtons = MODES[currentModeIndex] === "en_vi" 
        ? `<div class="action-container">
             <button class="show-text-btn" onclick="showQuestionText()">üëÅÔ∏è Hi·ªán t·ª´</button>
             <button onclick="playAudio('${audioWord}')">üîä Nghe</button>
           </div>`
        : "";
      
      const optionsHTML = options.map(opt => 
        `<button onclick="checkAnswer(this,'${opt.replace(/'/g,"\\'")}','${correctAnswer.replace(/'/g,"\\'")}')">${opt}</button>`
      ).join('');
      
      container.innerHTML = `<div class="word-card">
        <h3>${displayQuestion}</h3>
        ${actionButtons}
        ${optionsHTML}
        <button class="next-btn" id="nextBtn" style="display: none;" onclick="handleNext()">‚è≠Ô∏è T·ª´ ti·∫øp theo</button>
      </div>`;
    }

    function showQuestionText() {
      const questionElement = document.querySelector('.word-card h3');
      if (questionElement) {
        const hiddenSpan = questionElement.querySelector('.hidden-text');
        if (hiddenSpan) {
          hiddenSpan.classList.remove('hidden-text');
          hasShownText = true;
          
          // ·∫§n hi·ªán t·ª´ = reset level 0
          if (firstAttempt) {
            if (!wordResults[currentWord.w]) {
              wordResults[currentWord.w] = { en_vi: false, vi_en: false };
            }
            wordResults[currentWord.w][MODES[currentModeIndex]] = false;
            currentWord.l = 0;
            
            let question, correctAnswer;
            if (MODES[currentModeIndex] === "en_vi") {
              question = `${currentWord.w} [${currentWord.p}]`;
              correctAnswer = currentWord.m;
            } else {
              question = currentWord.m;
              correctAnswer = currentWord.w;
            }
            
            wrongQuestions.push({
              w: currentWord.w,
              mode: MODES[currentModeIndex],
              question: question,
              correctAnswer: correctAnswer,
              audioWord: currentWord.w
            });
            
            wrongAnswers++;
            firstAttempt = false;
          }
          
          document.getElementById("feedback").innerHTML = "‚ùå ƒê√£ hi·ªán t·ª´! T·ª´ n√†y s·∫Ω ƒë∆∞·ª£c ƒë∆∞a v·ªÅ level 0.";
          document.getElementById('nextBtn').style.display = 'block';
          updateProgressCounter();
        }
      }
    }

    function checkAnswer(btn, selected, correct) {
      const fb = document.getElementById("feedback");

      if (selected === correct) {
        btn.classList.add('correct-answer');
        
        // T·ª∞ ƒê·ªòNG PH√ÅT √ÇM THANH KHI CH·ªåN ƒê√öNG - CHO C·∫¢ 2 MODE
        setTimeout(() => {
          playAudio(currentWord.w);
        }, 500);
        
        if (firstAttempt) {
          // Ch·ªâ t√≠nh khi ch·ªçn ƒë√∫ng l·∫ßn ƒë·∫ßu V√Ä ch∆∞a ·∫•n hi·ªán t·ª´
          if (!hasShownText) {
            // ‚úÖ Case 1: Ch·ªçn ƒë√∫ng l·∫ßn ƒë·∫ßu, t·ª´ ·∫©n -> L√äN LEVEL
            if (!wordResults[currentWord.w]) {
              wordResults[currentWord.w] = { en_vi: false, vi_en: false };
            }
            wordResults[currentWord.w][MODES[currentModeIndex]] = true;
            correctAnswers++;
            fb.innerHTML = "‚úÖ ƒê√∫ng!";
          } else {
            // ‚ùå Case 2: ƒê√£ ·∫•n hi·ªán t·ª´ tr∆∞·ªõc ƒë√≥ -> RESET LEVEL 0
            if (!wordResults[currentWord.w]) {
              wordResults[currentWord.w] = { en_vi: false, vi_en: false };
            }
            wordResults[currentWord.w][MODES[currentModeIndex]] = false;
            currentWord.l = 0;
            wrongAnswers++;
            fb.innerHTML = "‚úÖ ƒê√∫ng nh∆∞ng ƒë√£ hi·ªán t·ª´ tr∆∞·ªõc! Level reset v·ªÅ 0";
          }
          
          firstAttempt = false;
        } else {
          // C√°c l·∫ßn ch·ªçn sau kh√¥ng t√≠nh
          fb.innerHTML = "‚úÖ ƒê√∫ng! (Kh√¥ng t√≠nh level)";
        }

        // HI·ªÜN N√öT NEXT KHI CH·ªåN ƒê√öNG (ch·ªâ mode en_vi)
        if (MODES[currentModeIndex] === "en_vi") {
          document.getElementById('nextBtn').style.display = 'block';
          // Ch·ªâ hi·ªán t·ª´ m√† kh√¥ng g·ªçi showQuestionText() ƒë·ªÉ tr√°nh th√¥ng b√°o reset level
          if (!hasShownText) {
            const questionElement = document.querySelector('.word-card h3');
            if (questionElement) {
              const hiddenSpan = questionElement.querySelector('.hidden-text');
              if (hiddenSpan) {
                hiddenSpan.classList.remove('hidden-text');
                hasShownText = true;
              }
            }
          }
        } else {
          // Mode vi_en: t·ª± ƒë·ªông chuy·ªÉn c√¢u sau 1.5 gi√¢y
          setTimeout(nextQuestion, 1500);
        }
      } else {
        btn.classList.add('incorrect-answer');
        if (firstAttempt) {
          // ‚ùå Case 3: Ch·ªçn sai l·∫ßn ƒë·∫ßu -> RESET LEVEL 0
          if (!wordResults[currentWord.w]) {
            wordResults[currentWord.w] = { en_vi: false, vi_en: false };
          }
          wordResults[currentWord.w][MODES[currentModeIndex]] = false;
          currentWord.l = 0;
          wrongAnswers++;
          
          let question, correctAnswer;
          if (MODES[currentModeIndex] === "en_vi") {
            question = `${currentWord.w} [${currentWord.p}]`;
            correctAnswer = currentWord.m;
          } else {
            question = currentWord.m;
            correctAnswer = currentWord.w;
          }
          
          wrongQuestions.push({
            w: currentWord.w,
            mode: MODES[currentModeIndex],
            question: question,
            correctAnswer: correctAnswer,
            audioWord: currentWord.w
          });
          
          firstAttempt = false;
          fb.innerHTML = "‚ùå Sai! Level reset v·ªÅ 0";
        } else {
          fb.innerHTML = "‚ùå Sai! (Kh√¥ng t√≠nh level)";
        }

        // KH√îNG HI·ªÜN N√öT NEXT KHI CH·ªåN SAI
        // Ch·ªâ hi·ªán t·ª´ ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt ƒë√°p √°n ƒë√∫ng
        if (!hasShownText) {
          const questionElement = document.querySelector('.word-card h3');
          if (questionElement) {
            const hiddenSpan = questionElement.querySelector('.hidden-text');
            if (hiddenSpan) {
              hiddenSpan.classList.remove('hidden-text');
              hasShownText = true;
            }
          }
        }
      }
      updateProgressCounter();
    }

    function handleNext() {
      nextQuestion();
    }

    function showResults(){
      // ƒê·∫¢M B·∫¢O RESET LEVEL CHO C√ÅC T·ª™ SAI
      wrongQuestions.forEach(wrong => {
        const wordObj = words.find(w => w.w === wrong.w);
        if (wordObj) {
          wordObj.l = 0;
        }
      });
      
      const container = document.getElementById("output");
      let html = "<h3>üìä K·∫øt qu·∫£ h·ªçc t·ª´</h3>";
      
      for (let w in wordResults) {
        const result = wordResults[w];
        const wordObj = words.find(word => word.w === w);
        const oldLevel = wordObj.l || 0;
        
        // T√≠nh level m·ªõi: PH·∫¢I ƒê√öNG C·∫¢ 2 MODE m·ªõi l√™n level
        const isCorrectBoth = result.en_vi && result.vi_en;
        // S·ª¨A: B·ªé GI·ªöI H·∫†N MAX LEVEL (t·ª´ 7 ‚Üí kh√¥ng gi·ªõi h·∫°n)
        const newLevel = isCorrectBoth ? (oldLevel + 1) : Math.max(0, oldLevel);
        
        wordObj.l = newLevel;
        
        html += `<div class="result-item">${w}: Level ${oldLevel} ‚Üí ${newLevel}</div>`;
        
        results.push({w: w, oldLevel, newLevel});
      }
      
      // L∆ØU K·∫æT QU·∫¢ V√Ä CHUY·ªÇN SANG TIME.HTML
      // TR∆Ø·ªúNG s V·∫™N GI·ªÆ NGUY√äN T·ª™ ƒê·∫¶U
      localStorage.setItem("selectedStudyWords", JSON.stringify(words));
      
      html += `
        <div class="action-buttons">
          <button onclick="goToTimePage()">‚è∞ T√≠nh th·ªùi gian √¥n t·∫≠p</button>
        </div>
      `;
      
      container.innerHTML = html;
    }

    function goToTimePage() {
      window.location.href = "time.html";
    }

    if (words.length > 0) {
      totalWords = words.length;
      updateProgressCounter();
      nextQuestion();
    }
  </script>
</body>
</html>